<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .container {
        height: 400vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .cube {
        width: 16px;
        height: 16px;
        position: relative;
        background: inherit;
        opacity: 1;
      }
      .test-text {
        font-size: 100px;
        position: relative;
        z-index: -1;
      }
      .fade-away-text-container {
        width: fit-content;
      }
      .cube-text {
        background-color: black;
        position: absolute;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="fade-away-text-container">
        <h2 class="test-text">Cube fade away</h2>
      </div>
    </div>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        let animationInterval = null; // Track the current interval

        function divideIntoCubesLoop(element, cubeSize = 16) {
          const { offsetWidth: width, offsetHeight: height } = element;
          const cols = Math.ceil(width / cubeSize);
          const rows = Math.ceil(height / cubeSize);
          // console.log(`Dividing into cubes: ${cols} cols x ${rows} rows`);

          const cubePositions = [];
          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
              cubePositions.push({ row, col });
            }
          }

          function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [array[i], array[j]] = [array[j], array[i]];
            }
          }

          function addCubes() {
            shuffleArray(cubePositions);
            let index = 0;

            animationInterval = setInterval(() => {
              if (!animationInterval) return;

              const batchSize = 100;
              const endIndex = Math.min(
                index + batchSize,
                cubePositions.length
              );

              for (let i = index; i < endIndex; i++) {
                const { row, col } = cubePositions[i];
                const cube = document.createElement("div");
                cube.classList.add("cube-text");
                cube.style.width = `${cubeSize}px`;
                cube.style.height = `${cubeSize}px`;
                cube.style.position = "absolute";
                cube.style.left = `${col * cubeSize}px`;
                cube.style.top = `${row * cubeSize}px`;
                cube.style.backgroundColor = "#fff";
                element.appendChild(cube);
              }

              index = endIndex;
              if (index >= cubePositions.length) {
                clearInterval(animationInterval);
                animationInterval = null;
                setTimeout(removeCubes, 500);
              }
            }, 50);
          }

          function removeCubes() {
            const cubes = Array.from(document.querySelectorAll(".cube-text"));
            shuffleArray(cubes);
            let index = 0;

            animationInterval = setInterval(() => {
              if (!animationInterval) return;

              const batchSize = 100;
              const endIndex = Math.min(index + batchSize, cubes.length);

              for (let i = index; i < endIndex; i++) {
                const cube = cubes[i];
                cube.remove();
              }

              index = endIndex;
              if (index >= cubes.length) {
                clearInterval(animationInterval);
                animationInterval = null;
                setTimeout(addCubes, 500);
              }
            }, 50);
          }

          addCubes();
        }

        // Intersection Observer
        const textElement = document.querySelector(".fade-away-text-container");
        textElement.style.position = "relative";

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                // console.log(
                //   "Container entered the viewport. Starting animation..."
                // );
                divideIntoCubesLoop(textElement, 10);
              } else {
                // console.log(
                //   "Container left the viewport. Stopping animation..."
                // );
                clearInterval(animationInterval);
                animationInterval = null;
                // Remove any remaining cubes
                const cubes = document.querySelectorAll(".cube-text");
                cubes.forEach((cube) => cube.remove());
              }
            });
          },
          {
            root: null, // Observe relative to the viewport
            threshold: 0.1, // Trigger when 10% of the element is visible
          }
        );

        observer.observe(textElement); // Start observing the container
      });
    </script>
  </body>
</html>
